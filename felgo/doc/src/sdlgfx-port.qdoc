/*!
\page sdlgfx-port-tutorial.html
\title Tutorial: How I ported a C++/SDL_gfx based application to Felgo

\image screen.gif "Felgo-Neurocid"

There are several ways to port C++/SDL_gfx based applications to Felgo. The most canonical way
would be to provide a model with all the game data needed for rendering and passing it to Felgo
app to do the heavy lifting as described here: \l{https://felgo.com/doc/apps-howto-model-view-separation/}{Model-view-separation-tutorial}.
But in case you want a quick result, your rendering just works fine the way it is, and you don't need any of the advantages of using Felgo for
rendering: This is the tutorial to read. The approach is pretty simple: Create a SDL_gfx drop-in replacement that behind the scenes uses
an extended QML \c Canvas element to do the actual drawing (do be more exact: \l{https://en.wikipedia.org/wiki/Rasterisation}{rasterisation}).
We are going to use a real-world example to demonstrate the approach: Neurocid - a space battle simulation driven by
\l{https://en.wikipedia.org/wiki/Genetic_algorithm}{a genetic algorithm} and \l{https://en.wikipedia.org/wiki/Artificial_neural_network}{artifical neural networks}.
The code for this tutorial resides in two \l{https://en.wikipedia.org/wiki/Git}{git-branches} of the Neurocid github project:
\list
\li \l{https://github.com/kallaballa/Neurocid/tree/master}{Neurocid master} - The code before the port
\li \l{https://github.com/kallaballa/Neurocid/tree/felgo}{Neurocid felgo} - The code after the port
\endlist

If you want all the changes at a glance you can \l{https://github.com/kallaballa/Neurocid/compare/master...felgo}{compare}
those branches but please be aware that not all of them are strictly necessary to achieve the goal of this tutorial.

Tutorial chapters:
\list 1
\li \l{Chapter 0: Comments on how I approached the challenge in general}
\li \l{Chapter 1: Building Neurocid for Debian Linux 10}
\li \l{Chapter 2: The Game}
\li \l{Chapter 3: Write a QML Canvas object that mimics a SDL_gfx-like API}
\li \l{Chapter 4: Write a C++ to QML Canvas bridge}
\li \l{Chapter 5: How to use the SDL_gfx-like drop-in replacement}
\li \l{Appendix: Issues with the Challenge and Felgo}
\endlist

Please have a look at training.sh to learn how to set up the environment and run felgo-neurocid
*/
/*!
\page comments-on-challenge.html
\title Chapter 0: Comments on how I approached the challenge in general

\list
\li I worked in a branch, so I can relax project disciplin (e.g.: allow myself to make uncontained or incomplete commits by mistake to safe reviewing time)
\li I disabled Neurocid features that were in the way and are not strictly necessary (e.g.: like compiling to javascript using emscripten or rendering a video)
\li Where possible I ignored Neurocid issues.
\li I chose to use only buttons because I was hoping to create an Android app (and programming a platform specific UX was clearly out of scope)
\li I held back on beautifying the App and the Docs because you are looking for a backend hacker.
\li I didn't fix issues/warnings in third-party code (e.g.: Box2D).
\li I made sure the project can be edited, build and run with and without QT-Creator.
\li I didn't test and benchmark to a professional extent but i made sure it runs on Ubuntu, Debian and OpenSUSE.
\li I didn't test for Mac OSX at all (which is a supported target of the master-branch)
\li I chose a quite ambigous task knowing it is significantly more work than required, because i wanted to implement something that wouldn't go to waist, no matter what.
\li In general it would be very nice if you could provide a full Felgo-qdoc-tutorial with config a qdoc document, style-sheets and assets.
\li Most of the time I'm not a last minute guy but job, family and virus-life took their toll.
\li I didn't include the appendix (just) to show off. If focus/given directions/time allow(s) it, I regard doing a tutorial as testing a tutorial (in projects I am involved in)
\li I didn't include the qt/qtdoc pitfalls that i encountered.
\endlist
*/
/*!
\page build-neurocid-debian.html
\title Chapter 1: Building Neurocid for Debian Linux 10
This chapter assumes a minimal Debian Linux 10 install as prerequisite.

First, let's install all build dependencies:
\code
su - # change to root
apt-get install git-core pkg-config cmake build-essentials g++ libsdl1.2-dev libsdl-gfx1.2-dev libsdl-image1.2-dev libsdl-ttf1.2-dev libboost-system-dev libboost-program-options-dev libboost-serialization-dev libsndfile1-dev
\endcode

For convenience we are going to install sudo and configure it:
\code
su - # change to root
apt-get install sudo
adduser <your user> sudo
\endcode

Please note, that you need to log out and back in for the changes to take effect (and hence being able to use sudo)
From this point all commands that are not prefixed with "sudo" should be run with the unprivileged user that you want to run felgo-neurocid with.

Next let's get the code. We are going to clone the "felgo" branch (not master!).
\code
git clone --branch felgo https://github.com/kallaballa/Neurocid
\endcode

Now we need to install Felgo. Please follow the corresponding \l{https://felgo.com/doc/felgo-installation/}{tutorial}
and make sure to install Felgo directly in your home folder (/home/<your user>/Felgo) or to adjust the variable "FELGO_PATH"
in the main Neurocid Makefile (Neurocid/Makefile). For example, if you installed Felgo to /opt/Felgo you need to change the variable to the following:
\code
FELGO_PATH :=/opt/Felgo/
\endcode

Now we are ready to build Neurocid (including the felgo frontend)!

\code
cd Neurocid/ # change to the Neurocid directory
\endcode

Start by building the third-party code of the repository:
\code
./build_deps.sh
\endcode

And now let's actually build neurocid including the felgo qt-project which resides in ./felgo/
\code
make -j4 # change 4 to the number of cores/hyperthreads/CPUS your system has to accelerate the build process. if you don't want to do a parallel build, just omit '-j4'
\endcode

And don't forget to install!
\code
sudo make install
\endcode
*/
/*!
\page run-neurocid.html
\title Chapter 2: The Game
The whole idea behind Neurocid is to train a swarm of "intelligent" space ships to fight another space ship team.
There are two things required to be able to train a swarm:
\list
\li A curriculum (a list of scenarios to train with one after the other) which can be defined by creating scenarios (either in C++ or as json file) and providing placers (Neurocid/lua/placer/)
\li A fitness function (the default fitness function resides in Neurocid/lua/fitness/amir.lua)
\endlist

Going into detail on how to do that exactly is out of scope for this tutorial but there is a shell script which provides everything required to run a curriculim.
To run the training do the following:
\code
cd Neurocid/
felgo/training.sh
\endcode

Please note that not every training is successful, even in perfect conditions. Reliability of the training depends very much on the population size.
A larger population raises the potential for desired development while slowing down the simulation, so if you'd like to experiment with a larger
population sizes be aware that it might actually take longer to successfully train a team.

To control the training felgo-neurocid takes following command line arguments:
\code
Usage: felgo-neurocid [options]

Options:
  -i [ --iterations ] arg  Run n iterations of the game
  -a [ --autosave ] arg    Automatically save teams every n minutes
  --loadA arg              Load the population as team A from a file before
                           running the scenario
  --loadB arg              Load the population as team B from a file before
                           running the scenario
  --saveA arg              Save the team A population to a file after running
                           the scenario
  --saveB arg              Save the team B population to a file after running
                           the scenario
  -f [ --framerate ] arg   The frame rate of the renderer
  -h [ --help ]            Produce help message
\endcode

\section1 Anatomy of the game
There are two teams consisting of space ships. Their ultimate goal is to destroy the other team which can be achieved through destroying each of the ships or destroying the enemy base. Each ship has a neural network as brain which controls all its actions. During training the teams follow a curriculum of scenarios and are evolved through genetic algorithms. Scenarios and fitness function are scriptable in lua.

\section2 Ships
\list
\li A ship can move and shoot projectiles.
\li A ship has a limited amount of fuel and projectiles.
\li A ship dies when it is out of fuel.
\li A ship can collide with out ships and suffers damage.
\li A ship hit by a projectile suffers damage.
\li A ship exceeding it's maximum damage dies.
\li In every game scenario ships start with minimal fuel and no ammunition. They can't just converge on enemy locations and empty their ammonition, they have to visit their own base first to restock both. Also, evertime they are low on fuel or ammonition they have to fly back.
\endlist


\section2 Projectiles
\list
\li A projectile has a limited speed but is faster than ships.
\li A projectile has a limited range and will explode on exceeding it.
\li A projectile will explode on impact. On friendly ships, enemy ships, friendly bases and enemy bases alike.
\li When a projectile explodes it creates a blast. Any ship in range of the blast will be stunned for a limited time.
\endlist

\section2 Bases
\list
\li A base supplies friendly ships flying over it with fuel and ammunition
\li A base can take limited damage before it is destroyed. Without a base the friendly team will starve since it can't restock fuel and ammunition.
\endlist

\section2 Game Objects
\list
\li Dark red dots with a trail of same color: Ships of team A moving conventionally
\li Dark green dots with a trail of same color: Ships of team B moving conventionally
\li Big lighter red dot: Base of team A
\li Big lighter green dot: Base of team B
\li White circle: Marks a ship which is stunned
\li Orange dots: Marks a projectile blast
\li Yellow dots; Projectiles of team A
\li Turquoise dots: Projectiles of team B
\li White bar next to bases: Health indicator of the base
\endlist

\image gameobjectoverview.png "Game Objects Overview"

*/
/*!
\page felgo-neurocid-structure.html
\title Chapter 4: Felgo-neurocid project structure

*/
/*!
\page write_qml_canvas.html
\title Chapter 3: Write a QML Canvas object that mimics a SDL_gfx-like API
SDL_gfx provides a simple and straight-forward \l {https://www.ferzkopp.net/Software/SDL_gfx-2.0/Docs/html/_s_d_l__gfx_primitives_8h.html}{API} for rasterising vector graphics.
What we need to do is extend a QML Canvas with methods resembling the SDL_gfx-functions we require. Let's say for the sake of simplicity we require straight-lines only.
The following sections shows an example of QML Canvas that supports exactly that. Please note that the renderTarget and renderStrategy are educated guesses and that
the helper functions preceding the function lineRGBA are required to generate html color-hex-strings (e.g: "#ff0000" for pure red), to clear the whole canvas and to control the
framebuffer.
You can find the full implementation in GfxCanvas

\qml
Canvas {
    renderTarget: Canvas.Image;
    renderStrategy: Canvas.Immediate;
    //VERY important. we need the objectName so we can find the object in the C++ code.
    objectName: "gfxCanvas"

    //Creates a hex string from an integer value with a value from 0 to 255. If the resulting
    //string consists of only one character a leading zero is added.
    function makePadded8BitHexString(v) {
        if(v < 0 || v > 255) {
            console.error("makePadded8BitHexString: value out of bounds");
            return "00";
        } else {
            var vHex = v.toString(16);
            if(vHex.length === 1) {
                return "0" + vHex;
            } else {
                return vHex;
            }
        }
    }

    //Creates an html like rgb hex-string. e.g.: "#ff0000" for pure red
    function makeHtmlColorString(r, g, b) {
        return "#" + makePadded8BitHexString(r) +
                makePadded8BitHexString(g) +
                makePadded8BitHexString(b)
    }

    //Sets the fill and stroke color of the 2d context.
    function setRGBA(ctx, r, g, b, a) {
        if(a < 0 || a > 255) {
            console.error("setRGBA: alpha value out of bounds");
            return;
        }
        ctx.globalAlpha = a / 255.0;
        ctx.fillStyle = ctx.strokeStyle = makeHtmlColorString(r, g, b);
    }

    //Fill the whole Canvas with the provided RGB color
    function clear(r,g,b) {
        var ctx = getContext("2d");
        setRGBA(ctx, r,g,b,255);
        ctx.fillRect(0, 0, width, height);
    }

    //Flip the framebuffer and therefor display what has been rendered off-screen
    function flip() {
        requestPaint();
    }

    //the actual code drawing a line using the 2d graphics context
    function lineRGBA(x1, y1, x2, y2, r, g, b, a) {
        var ctx = getContext("2d");
        setRGBA(ctx, r, g, b, a);
        ctx.beginPath();
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);
        ctx.stroke();
    }
}
\endqml
*/
/*!
\page write_a_cpp_to_qml_bridge.html
\title Chapter 4: Write a C++ to QML Canvas bridge
The following code demonstrates how to call the corresponding QML method from C++. Please note that the functions "flip" and "clear" don't have a corresponding SDL_gfx function
but are still required to be effectivly able to render. "flip" performs a buffer flip of the framebuffer (which you need to do after you've done all the drawing operations to actually display
the frame (see \l {https://en.wikipedia.org/wiki/Multiple_buffering#Double_buffering_in_computer_graphics}{double buffering}) and "clear" fills the whole canvas with the RGB color provided.
There are several ways to call the QML Canvas methods (e.g.: using signals/slots) but i chose the QMetaObject::invokeMethod approached because i wanted tight(er) binding than the message passing of signals/slots provides.
Also I couldn't find a use case that would require binding those functions many times from many locations.
You can find the full implementation in felgogfx.cpp

\code
FelgoGFX::FelgoGFX(QObject* canvas) : canvas_(canvas) {
}

//except for the return value this function behaves like explained here: https://www.ferzkopp.net/Software/SDL_gfx-2.0/Docs/html/_s_d_l__gfx_primitives_8h.html#a5e4bd13b12d34698fbcb2dc9d3a0e9f3
void FelgoGFX::lineRGBA(const int16_t& x1, const int16_t& y1, const int16_t& x2, const int16_t& y2, const uint8_t& r, const uint8_t& g, const uint8_t& b, const uint8_t& a) {
    QMetaObject::invokeMethod(canvas_, "lineRGBA",
                              Q_ARG(QVariant, x1),
                              Q_ARG(QVariant, y1),
                              Q_ARG(QVariant, x2),
                              Q_ARG(QVariant, y2),
                              Q_ARG(QVariant, r),
                              Q_ARG(QVariant, g),
                              Q_ARG(QVariant, b),
                              Q_ARG(QVariant, a)
                              );
}

//This function has no corresponding function in SDL_gfx. It fills the whole canvas with a uniform color.
void FelgoGFX::clear(const uint8_t& r, const uint8_t& g, const uint8_t& b) {
  QMetaObject::invokeMethod(canvas_, "clear",
                            Q_ARG(QVariant, r),
                            Q_ARG(QVariant, g),
                            Q_ARG(QVariant, b)
                            );
}

//This function has no corresponding function in SDL_gfx but it serves the same purpose as SDL_Flip, though the exact semantics are very different.
void FelgoGFX::flip() {
  QMetaObject::invokeMethod(canvas_, "flip");
}
\endcode
*/
/*!
\page howto_use_replacement.html
\title Chapter 5: How to use the SDL_gfx-like drop-in replacement

The following code shows an example of how to use the API we created.
You can find the full implementation in main.cpp

\code
    //A common felgo boiler-plate
    QApplication app(argc, argv);
    FelgoApplication felgo;
    QQmlApplicationEngine engine;
    felgo.initialize(&engine);

    //load main qml file
    felgo.setMainQmlFileName(QStringLiteral("qml/GfxCanvasExample.qml"));
    engine.load(QUrl(felgo.mainQmlFileName()));

    //find the gfxCanvas QML object by the objectName we assigned in Chapter 3
    QObject *qmlGfxCanvas = rootObjs.first()->findChild<QObject*>("gfxCanvas");

    std::thread gameThread([=]() {
        //wait for the GfxCanvas to become available
        while(!qmlGfxCanvas->property("available").toBool()) {
            std::this_thread::sleep_for(std::chrono::milliseconds(100));
            std::cerr << "wait" << std::endl;
        }

        //Instantiate our C++ to QML bridge.
        FelgoGFX* felgoGfx = new nc::FelgoGFX(qmlGfxCanvas);

        while(true) {
            //fill the canvas black
            felgoGfx.clear(0,0,0)
            //draw a line
            felgoGfx.lineRGBA(0,0,100,100,255,0,0,255);
            //display what we have drawn
            felgoGfx.flip();
        }
    });

    gameThread.detach();

    //now that everything is setup, run the felgo applications
    return app.exec();
\endcode
*/
/*!
\page appendix-challenge.html
\title Appendix: Issues with the Challenge and Felgo

\list
\li The first link in "https://docs.google.com/document/d/1lWUHemIXMqJQfc3OkmarzQ2dlokDPTrpJa5NXJWNIkI/edit" is a 404.
\li In the Fedora instructions "https://felgo.com/cross-platform-development/install-felgo-on-fedora" you recommend the following:
\code
cd lib64/
sudo chown root:root libcrypto.so.1.0.0 libssl.so.1.0.0
sudo cp libcrypto.so.1.0.0 libssl.so.1.0.0 /usr/lib64/
\endcode
The above procedure is problematic for 3 reasons:

\list
\li Shipping binaries for dependencies isn't a wise thing to do in general, but in this case you are shipping outdated versions of *very* security-related libraries and furthermore you suggest to install them to the system permanently for other programs to use. That is a very real (and easily avoidable) security risk. Apart from the security risk there is a series of other problems arising from that (ask if you want me to go into further detail)
\li Changing ownership of the file beforehand and copying after has no effect if the files already exist in /usr/lib64/ (or just one exist, which might lead users to the tutorial)
For example:
\code
# create two files with unprivileged (= no root) ownership.
touch userfile
touch rootfile

# Change ownership of one of the files to root.
sudo chown root:root rootfile

# View the result
ls -l userfile rootfile
-rw-r--r-- 1 felgouser  users 0 Apr  1 20:05 userfile
-rw-r--r-- 1 root       root  0 Apr  1 20:05 rootfile

# Copy rootfile over userfile
cp rootfile userfile

# View the result
ls -l userfile rootfile
-rw-r--r-- 1 felgouser  users 0 Apr  1 20:06 userfile
-rw-r--r-- 1 root       root  0 Apr  1 20:06 rootfile

# Please note, that the ownership of the target file (userfile) has not changed,

\endcode

\li According to the FHS (https://en.wikipedia.org/wiki/Filesystem_Hierarchy_Standard) the proper place to store local changes to the system is in the /usr/local/ tree. Adhering to that convention prevents problems emerging from file conflict and makes management of local changes much easier.
\endlist

There are two solutions for these problems:
\list
\li Use LD_LIBRARY_PATH

For example:
\code
# Make sure libraries are looked for in ./lib64 first.
LD_LIBRARY_PATH="./lib64:$LD_LIBRARY_PATH" ./FelgoInstaller-linux_x64-online.run
\endcode

\li If you really want to install a library permanently use a different path e.g: "/usr/local/lib64" (or "/usr/local/lib" depending on the distro) and instead of "chown + cp" use a different coreutil: "install".

For example:
\code
# copies the files to /usr/local/lib64 while making backups of existing files (if there are any). Finally sets the ownership to root.
sudo install -b -o root lib64/libcrypto.so.1.0.0 lib64/libssl.so.1.0.0 /usr/local/lib64
\endcode
\endlist
\li The samplelauncher renders fonts very small (OpenSUSE Tumbleweed using X11 with awesome WM and picom at 1920x1080 with 96dpi).
\li Installing Felgo on a fresh minimal Debian 10 requires a dependency not covert by the tutorial: libfontconfig1
\li Without a headless installer I had to do workarounds to install Felgo on my headless build-server.
\endlist
*/
